<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MySQL优化 | abellmz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="mysql易学难精">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL优化">
<meta property="og:url" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="abellmz">
<meta property="og:description" content="mysql易学难精">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1554272046.jpg">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555039230364.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555039755952.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555041185351.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555043061222.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555043680023.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555060325521.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555060417809.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555060746202.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555061556615.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555061413876.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555398326846.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555398407219.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555208384192.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555226439400.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555294548058.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555386995622.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555304075969.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555304162326.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555305079915.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555306250151.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555306332660.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555315348612.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555384095779.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555384696978.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555385202556.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555386841948.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555386149521.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555399507745.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555809463705.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555810980572.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555811815331.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555811881764.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555817190855.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555818578413.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555818473017.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555819321180.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555820247537.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555820517707.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555821828985.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555822396356.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555822698414.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555847075431.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555848649926.png">
<meta property="og:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555848739640.png">
<meta property="article:published_time" content="2019-04-22T07:28:02.000Z">
<meta property="article:modified_time" content="2025-05-13T03:14:10.842Z">
<meta property="article:author" content="abellmz">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/1554272046.jpg">
  
    <link rel="alternate" href="/atom.xml" title="abellmz" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">abellmz</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-mysql优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/22/mysql%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2019-04-22T07:28:02.000Z" itemprop="datePublished">2019-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MySQL优化
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>mysql易学难精</p>
<span id="more"></span>
<h3 id="mysql的架构介绍"><a class="markdownIt-Anchor" href="#mysql的架构介绍"></a> Mysql的架构介绍</h3>
<h4 id="mysql简介"><a class="markdownIt-Anchor" href="#mysql简介"></a> mysql简介</h4>
<h5 id="mysql概述"><a class="markdownIt-Anchor" href="#mysql概述"></a> mysql概述</h5>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1554272046.jpg" alt></p>
<h3 id="mysql优化"><a class="markdownIt-Anchor" href="#mysql优化"></a> mysql优化</h3>
<h4 id="mysql55安装"><a class="markdownIt-Anchor" href="#mysql55安装"></a> mysql5.5安装：</h4>
<p>yum下载的mysql是5.1版本，但我们需要至少5.5版本</p>
<p>1、方法一</p>
<p>mysql开发者相关文档	<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p>
<p>下载5.5教程<a href="https://www.cnblogs.com/littlemonsterksn/p/10154662.html">https://www.cnblogs.com/littlemonsterksn/p/10154662.html</a></p>
<p>wget是Linux系统中的一个下载文件的命令工具。对于经常要下载一些软件或从远程服务器恢复备份到本地服务器的用户来说是必不可少的工具。</p>
<p>没有wget就下一个：yum -y install wget</p>
<p>得到安装包：mysql-5.5.62-linux-glibc2.12-x86_64.tar.gz，解压后安装</p>
<p>方法二</p>
<p>在资料中找到了对应mysql5.5的rpm包，本地上传到Linux</p>
<p>pscp -r D:\MySQL\MySQL高级\mysql5.5.48 <a href="mailto:root@192.168.1.15">root@192.168.1.15</a>:/opt</p>
<p>上传成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin --version有东西说明安装成功</span><br><span class="line">service mysql start</span><br><span class="line">mysql——出现欢迎词，开始按照提示设置密码</span><br><span class="line">/usr/bin/mysqladmin -u root password 123456</span><br><span class="line">mysql——出现报错</span><br><span class="line">mysql -u root -p出现欢迎词</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>top命令后，实时显示系统中各个进程的资源占用状况，即当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等。</p>
<p>可以参考：</p>
<p><a href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html">https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html</a></p>
<p><strong>设置开机自启动mysql</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chkconfig mysql on</span><br><span class="line">chkconfig --list|grep mysql</span><br><span class="line">ntsysv	命令用于设置系统的各种服务,报不是命令就下载-&gt; yum install ntsysv</span><br></pre></td></tr></table></figure>
<p>看到【*】mysql,表示开机后 自动启动mysql（带星号表示，开机自启动，反之相反）</p>
<p><strong>修改配置文件位置：</strong></p>
<p>将 /usr/share/mysql/my-huge.cnf拷贝到/etc下</p>
<p>cp  /usr/share/mysql/my-huge.cnf  /etc/my.cnf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service mysql stop</span><br><span class="line">service mysql start</span><br><span class="line">mysql -u root -p登录，建立数据库和表发现中文乱码</span><br></pre></td></tr></table></figure>
<p>修改字符集和数据存储路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;character%&#x27;;</span><br><span class="line">发现database（客户端）和server（服务器）都是用的latinl，所以乱码</span><br></pre></td></tr></table></figure>
<p>在 /etc/my.cnf对应位置修改</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555039230364.png" alt></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555039755952.png" alt></p>
<p>修改完成后重新启动mysql,添加数据还是中文乱码原因：配置文件没错，否者不能重新启动mysql，乱码的原因是库在修改配置之前建立，因此装完mysql之后应该立即修改配置文件。</p>
<p>MySQL的安装位置——在linux下查看安装目录ps -ef|grep mysql</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555041185351.png" alt></p>
<h4 id="mysql存储引擎"><a class="markdownIt-Anchor" href="#mysql存储引擎"></a> mysql存储引擎：</h4>
<p><strong>查看命令：</strong></p>
<p>两种引擎可否混用？</p>
<p>引擎是针对表，而不是针对库的，在建表的时候声明成不同的引擎即可。 比如： CREATE TABLE <code>test_1</code> ( <code>name</code> varchar(20) DEFAULT NULL, <code>year</code> int(5) DEFAULT NULL ) ENGINE=MyISAM</p>
<p><strong>两种存储引擎区别</strong></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555043061222.png" alt></p>
<p><strong>阿里巴巴、淘宝用哪个</strong></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555043680023.png" alt></p>
<h4 id="索引优化"><a class="markdownIt-Anchor" href="#索引优化"></a> 索引优化</h4>
<p><strong>性能下降SQL慢、执行时间长、等待时间长</strong>的原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.查询语句写的烂</span><br><span class="line">2.索引失效</span><br><span class="line">3.关联查询太多join(设计缺陷或不得已的需求)</span><br><span class="line"></span><br><span class="line">4.服务器调优及各个参数设置（缓冲、线程等）</span><br></pre></td></tr></table></figure>
<h5 id="索引写操作"><a class="markdownIt-Anchor" href="#索引写操作"></a> 索引写操作</h5>
<p>索引主要分类：</p>
<p>1.主键索引 2.唯一索引3.普通索引 4.组合索引5.全文索引</p>
<p>索引CREATE创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON  table_name (col_name,...)</span><br><span class="line"></span><br><span class="line">单值索引</span><br><span class="line">创建索引 索引名idx_表名_字段名 on 表名（字段名）</span><br><span class="line">create index idx_user_name on user (name)</span><br><span class="line">复合索引</span><br><span class="line">创建索引 索引名（idx_表名_字段名字段名）on 表名（字段名，字段名）</span><br><span class="line">create index idx_user_nameEmail on user (name,email)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在MySQL中，默认情况下，一个查询只能使用一个索引来访问数据。</p>
<p>不过，MySQL支持索引合并，允许在某些特定条件下使用多个索引。</p>
<p><strong>索引合并</strong></p>
<p>1.并集合并（Union Merge）</p>
<p>当查询的 <code>WHERE</code> 子句中包含多个条件，且这些条件之间使用 <code>OR</code> 连接时，MySQL 会分别扫描每个条件对应的索引，然后取结果的并集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE key1 = &#x27;value1&#x27; OR key2 = &#x27;value2&#x27;;</span><br></pre></td></tr></table></figure>
<p>如果 <code>key1</code> 和 <code>key2</code> 列上都有索引，MySQL 可能会选择使用并集合并策略，分别扫描这两个索引，获取满足每个条件的记录，然后合并结果集，返回满足任一条件的用户记录</p>
<p>2.交集合并（Intersection Merge）</p>
<p>查询的 <code>WHERE</code> 子句中包含多个条件，且这些条件之间使用 <code>AND</code> 连接时，MySQL 会分别扫描每个条件对应的索引，然后取结果的交集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE first_name = &#x27;John&#x27; AND last_name = &#x27;Doe&#x27; AND age = 30;</span><br></pre></td></tr></table></figure>
<p>如果 <code>first_name</code>、<code>last_name</code> 和 <code>age</code> 列上都有单独的索引，MySQL 的查询优化器可能会选择使用交集合并策略，分别扫描这三个索引，获取满足每个条件的记录，然后取这些记录的交集作为最终的结果集。</p>
<p>3.排序并集合并（Sort-Union Merge）</p>
<p>适用于 <code>OR</code> 连接的条件，特别是当涉及范围查询时。在这种情况下，MySQL 会先对每个索引查找的结果进行排序，然后再进行合并</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE col1 &lt; value1 OR col1 &gt; value2;</span><br></pre></td></tr></table></figure>
<p>不适合索引合并的情况：</p>
<p>1.索引合并主要适用于 B-tree 索引，全文索引不支持索引合并。</p>
<p>2.对于存在范围查询（如 <code>BETWEEN</code>、<code>&lt;</code>、<code>&gt;</code> 等）或 <code>ORDER BY</code> 子句的查询，MySQL 可能不会使用索引合并，而是选择使用单个索引或进行全表扫描。</p>
<p>3.如果某个索引的选择性较差（即该索引列中有大量重复值，区分度较小），查询优化器可能不会选择该索引进行合并。</p>
<p>当两个表 <code>JOIN</code> 时，如果两个表的索引都被使用，这表明每个表都利用了自己的索引进行高效的查找。这是独立索引的使用，不是索引合并。索引合并是MySQL 中一种用于在单个表上使用多个索引的优化策略。</p>
<p><strong>单值索引和复合索引如何选择</strong></p>
<p>单值索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">简单易用：单值索引结构简单，易于创建和维护。</span><br><span class="line">适用范围广：适用于查询条件中涉及单个列的情况。</span><br><span class="line">灵活组合：多个单值索引可以在某些情况下被 MySQL 的查询优化器合并使用（索引合并）。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">效率问题：对于涉及多个列的查询条件，单值索引可能无法充分发挥作用，查询效率可能不如复合索引。</span><br></pre></td></tr></table></figure>
<p>复合索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">高性能：对于涉及多个列的查询条件，复合索引可以显著提高查询效率，尤其是当查询条件中的列顺序与复合索引的列顺序匹配时。</span><br><span class="line">覆盖查询：如果查询中的所有列都在复合索引中，MySQL 可以直接通过索引获取数据，无需回表查询（覆盖索引）。</span><br><span class="line">缺点：</span><br><span class="line">维护成本高：复合索引的维护成本较高，插入、更新和删除操作可能会影响索引的性能。</span><br><span class="line">顺序敏感：复合索引的列顺序非常重要，只有查询条件中的列顺序与复合索引的列顺序匹配时，才能有效利用索引。</span><br><span class="line"></span><br><span class="line">在 MySQL 中，复合索引本身不会被MySQL查询优化器合并使用</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>选择复合索引的场景</strong>：
<ul>
<li>查询条件中经常同时使用多个列。</li>
<li>查询条件中的列具有明显的过滤顺序（某些列的过滤效果更好）。</li>
<li>查询可以被复合索引覆盖（覆盖索引）。</li>
</ul>
</li>
<li><strong>选择单值索引的场景</strong>：
<ul>
<li>表中的查询条件通常只涉及单个列。</li>
<li>表需要支持多种不同的查询条件组合，难以通过复合索引来覆盖所有情况。</li>
<li>表的插入、更新和删除操作非常频繁，且对性能要求较高。</li>
</ul>
</li>
</ul>
<p><strong>ALTER</strong>命令添加数据表索引:</p>
<p>1.添加一个主键，意味着索引值必须是唯一的，且不能为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)</span><br></pre></td></tr></table></figure>
<p>2.这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD UNIQUE index_name(column_list)</span><br></pre></td></tr></table></figure>
<p>3.添加普通索引，索引值可出现多次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD INDEX index_name(column_list)</span><br></pre></td></tr></table></figure>
<p>4.该语句指定了索引为FULLTEXT，用于全文索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD FULLTEXT index_name(column_list)</span><br></pre></td></tr></table></figure>
<p>全文索引可以高效地支持复杂的文本搜索操作，适用于**<code>TEXT</code><strong>、</strong><code>VARCHAR</code><strong>、</strong><code>CHAR</code>**类型字段</p>
<p><strong>删除索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON talbe_name</span><br><span class="line">ALTER TABLE table_name DROP INDEX index_name</span><br><span class="line">ALTER TABLE table_name DROP PRIMARY KEY</span><br></pre></td></tr></table></figure>
<p>mysql300万记录以内没问题，超过就需要优化。</p>
<h5 id="常见通用的join查询"><a class="markdownIt-Anchor" href="#常见通用的join查询"></a> 常见通用的Join查询</h5>
<p>SQL执行顺序</p>
<p>手写</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555060325521.png" alt></p>
<p>机读</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555060417809.png" alt></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555060746202.png" alt></p>
<p>join关联图：内连接、外连接（ 左(外)连接、右(外)连接、全(外)连接）、笛卡尔积</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555061556615.png" alt></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555061413876.png" alt></p>
<p>join 等同于 inner join，默认是内连接.</p>
<p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录。</p>
<p>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录。</p>
<p>inner join(等值连接) 只返回两个表中联结字段相等的行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A inner join B on A.id = B.id;</span><br><span class="line">select * from A join B on A.id = B.id;</span><br><span class="line">select * from A,B where A.id = B.id;</span><br></pre></td></tr></table></figure>
<p>MySQL不支持全外连接，但可以模拟，详细看《笛卡尔积-内连接-外连接》。</p>
<h5 id="join语句优化"><a class="markdownIt-Anchor" href="#join语句优化"></a> <strong>join语句优化：</strong></h5>
<p>主键自带主键索引（不需要建立）</p>
<p>尽可能减少join语句中NestedLoop的循环总次数（不要join过多或嵌套）；</p>
<p>永远用小表驱动大表（根据数据量大小区分大表和小表，嵌套循环访问，详细看后面扩展）；</p>
<p>优先优化NestedLoop的外层循环（即驱动表），其次是内层循环（被驱动表）；</p>
<p>保证join语句中被驱动表（大表）上join字段已经被索引；</p>
<p>当无法保证被驱动表的join条件字段被索引，在内存资源充足的前提下，不要吝啬JoinBuffer的设置；</p>
<p>驱动表的索引优化是为了减少外层循环的次数，而内层循环的优化是为了减少每次内层循环的执行时间，两者相辅相成。</p>
<p><strong>查询优化</strong>——永远小表驱动大表类似全套循环NestedLoop，这里的“小表”和“大表”是相对的，指的是表的数据量大小。</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555398326846.png" alt></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555398407219.png" alt></p>
<p>扩展</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NestedLoop的工作原理————所谓嵌套</span><br><span class="line">两个表 A（驱动表，outer table）和 B（被驱动表，inner table），Nested Loop 的执行过程如下：</span><br><span class="line">1.从驱动表 A 中读取一行。</span><br><span class="line">2.对于这一行，遍历被驱动表 B 中的所有行，查找满足连接条件的行。</span><br><span class="line">3.重复上述步骤，直到驱动表 A 中的所有行都被处理完毕。</span><br><span class="line">Nested Loop 的循环次数主要由驱动表的行数决定。因此，减少循环次数的关键在于尽可能降低驱动表的行数.以下是一些优化策略：</span><br><span class="line">1.选择较小的表作为驱动表：将较小的表作为驱动表，可以减少外层循环的次数，从而减少总的循环次数。</span><br><span class="line">2.使用索引：在连接条件和过滤条件上使用索引，可以减少被驱动表的扫描范围，从而减少内层循环的次数。</span><br><span class="line">3.添加过滤条件：在驱动表上添加过滤条件，可以减少驱动表的行数。</span><br><span class="line">4.优化查询顺序：通过调整查询顺序，使驱动表的行数尽可能少。</span><br><span class="line"></span><br><span class="line">Nested Loop 和子查询的区别：</span><br><span class="line">Nested Loop 是一种连接算法，用于执行表之间的连接操作。而子查询（Subquery）是一种查询嵌套方式，用于在查询中嵌套另一个查询。Nested Loop 主要用于多表连接，而子查询可以用于各种复杂的查询场景，包括单表查询和多表查询。</span><br><span class="line"></span><br><span class="line">每join一个表就嵌套一层循环，但总体上是只查询了一次。而子查询，每多一个子查询，则会多一次查询。</span><br><span class="line"></span><br><span class="line">怎么知道哪个表是驱动表哪个表是被驱动表：</span><br><span class="line">在 SQL 查询中，特别是涉及多个表的 JOIN 操作时，驱动表（outer table）和被驱动表（inner table）的身份并不是固定的，而是由查询优化器根据多种因素动态确定的。通常较小的表更适合作为驱动表，因为扫描小表的速度更快，能更快地生成驱动行来访问被驱动表，当然主要还得看查询优化器的选择。</span><br><span class="line">当没有索引时，优化器主要依据表的大小和数据量、查询条件的过滤效果等因素来决定连接顺序。较小的表或能通过条件过滤掉大量数据的表更可能被选为驱动表。</span><br><span class="line">如果有索引，优化器会评估使用索引的成本，包括索引的查找成本和通过索引访问数据的成本。如果索引能够显著降低连接操作的总成本，优化器会调整连接顺序，将能高效利用索引的表作为驱动表。索引的存在使得优化器有更多选择来优化查询计划。</span><br><span class="line">最直接和可靠的方法是使用 EXPLAIN 查看查询执行计划，从而知晓哪个表是驱动表或被驱动表。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>t1</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>100</td>
<td>NULL</td>
</tr>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>t2</td>
<td>ref</td>
<td>t1_id</td>
<td>t1_id</td>
<td>4</td>
<td><a href="http://t1.id">t1.id</a></td>
<td>10</td>
<td>Using index</td>
</tr>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>t3</td>
<td>ref</td>
<td>t2_id</td>
<td>t2_id</td>
<td>4</td>
<td><a href="http://t2.id">t2.id</a></td>
<td>5</td>
<td>Using index</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain可以查看查询执行计划，从而确定哪个表是驱动表，哪个表是被驱动表。</span><br><span class="line"></span><br><span class="line">通过观察table列的顺序，可以确定查询中表的访问顺序。通常，第一个表（id最小的表）是驱动表，后续的表是被驱动表。在EXPLAIN输出中，id值相同的表属于同一个SELECT查询，id值较小的通常是外层查询，而较大的id值表示子查询或衍生表。id值越大，表示该查询越先被执行。</span><br><span class="line">如上表，table1相对于table2是驱动表，table2相对于table3是驱动表，整体上看table1是驱动表，其他都是被驱动表。</span><br></pre></td></tr></table></figure>
<h5 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> <strong>性能分析</strong></h5>
<p>MySql Query optimizer(mysql查询优化器)</p>
<ol>
<li>
<p>MySql中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间）</p>
</li>
<li>
<p>MySQL Query Optimizer工作流程<br>
1）当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer。<br>
2）MySQL Query Optimizer首先会对整条Query进行优化，将一些常量表达式换算成常量值，并对查询条件进行简化和转换（如去掉一些无用或显而易见的条件、结构调整等）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">SELECT * FROM table WHERE 1=1 AND column = &#x27;value&#x27;;</span><br><span class="line">简化处理后</span><br><span class="line">SELECT * FROM table WHERE column = &#x27;value&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM table WHERE column = &#x27;value1&#x27; OR column = &#x27;value2&#x27; OR column = &#x27;value3&#x27;;</span><br><span class="line">转为：</span><br><span class="line">SELECT * FROM table WHERE column IN (&#x27;value1&#x27;, &#x27;value2&#x27;, &#x27;value3&#x27;);</span><br><span class="line"></span><br><span class="line">即常量表达式计算、去掉无用的条件、去掉冗余的条件、转换OR为IN、 转换子查询为连接查询、转换连接查询（join）为子查询、转换OR条件为UNION、转换DISTINCT为GROUP BY等</span><br></pre></td></tr></table></figure>
<p>3）然后分析Query中的Hint信息（如果有），看显示的Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hint信息：hint（提示）是用户给数据库查询优化器的指令，用于指定查询的执行计划或影响优化器的选择。</span><br><span class="line">MySQL提供了多种类型的hint，比如USE INDEX：</span><br><span class="line">SELECT /*+ USE INDEX (idx_column1) */ column1, column2</span><br><span class="line">FROM table</span><br><span class="line">WHERE column1 = &#x27;value1&#x27;;</span><br><span class="line">或者IGNORE INDEX：</span><br><span class="line">SELECT /*+ IGNORE INDEX (idx_column1) */ column1, column2</span><br><span class="line">FROM table</span><br><span class="line">WHERE column1 = &#x27;value1&#x27;;</span><br><span class="line">还有：FORCE INDEX、JOIN ORDER、MAX_EXECUTION_TIME。</span><br><span class="line"></span><br><span class="line">hint信息是用户（如开发者或数据库管理员）根据对查询和数据库的理解，手动添加到SQL语句中的特殊指令。在大多数情况下，数据库的查询优化器能够自动为查询生成高效的执行计划，因此hint不是必需的。只有在查询优化器无法生成理想执行计划，且用户认为自己可以指定更好的计划时，才会考虑使用hint。hint不仅可以由数据库管理员（DBA）使用，也可以由应用开发者在编写SQL语句时添加。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>mysql常见瓶颈（略）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.查询性能瓶颈</span><br><span class="line">查询语句不合理、索引缺失或使用不当，会导致查询执行时间长。</span><br><span class="line">2.硬件资源瓶颈</span><br><span class="line">CPU瓶颈：数据库操作过程中，CPU资源消耗过大，可能导致响应延迟。高 CPU 使用率会使得数据库处理请求变慢。</span><br><span class="line">内存瓶颈：内存不足会导致数据库缓存不足，增加磁盘 I/O 操作，降低查询效率。频繁的磁盘交换会严重影响性能。</span><br><span class="line">磁盘I/O瓶颈：磁盘读写速度慢，会导致数据访问延迟，影响数据库性能。全表扫描、大量数据插入等操作会加重磁盘 I/O 负载。</span><br><span class="line">3.锁竞争和死锁</span><br><span class="line">过多的锁竞争或死锁现象会导致并发操作等待时间增加，降低系统性能。</span><br><span class="line">4.大量慢查询</span><br><span class="line">存在大量耗时较长的慢查询语句会导致系统性能下降。</span><br><span class="line">5.数据库设计问题</span><br><span class="line">不合理的表设计、冗余字段、过多的关联查询等会影响性能。</span><br><span class="line">6.数据库连接池配置不当</span><br><span class="line">连接池设置不合理，导致连接数不足或过多，影响系统的并发处理能力。</span><br><span class="line">7.数据量和索引过大</span><br><span class="line">当数据量庞大或索引过多时，查询性能会下降。可以考虑分区、分表等策略来减轻压力，提高查询效率。</span><br><span class="line">8.错误配置或参数设置不当</span><br><span class="line">MySQL的配置文件中的参数设置对性能有重要影响。若配置不当，可能导致性能瓶颈。可以根据实际需求进行适当的配置和参数调优。</span><br></pre></td></tr></table></figure>
<h5 id="explain关键字"><a class="markdownIt-Anchor" href="#explain关键字"></a> <strong>Explain关键字：</strong></h5>
<p><a href="https://www.cnblogs.com/dlp-527/p/11824467.html">https://www.cnblogs.com/dlp-527/p/11824467.html</a></p>
<p>用法：Explain+SQL语句，可以获取 SQL 查询的执行计划（执行计划是数据库查询优化器决定如何执行查询的详细步骤）。</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555208384192.png" alt></p>
<p><strong>id</strong>:查询中每个子查询或表的执行顺序标识符，<code>id</code> 相同，表示这些查询可以并行执行； <code>id</code> 不同，数字越大，优先级越高，越先被执行。</p>
<p>select_type：查询类型，描述了查询中每个 <code>SELECT</code> 子句的性质。常见的类型包括 <code>SIMPLE</code>（简单查询）、<code>PRIMARY</code>（主查询）、<code>SUBQUERY</code>（子查询）、<code>UNION</code>（联合查询的一部分）、<code>derived</code>(表示该查询是一个派生表)等。</p>
<p>table：显示与查询相关的表的名称。通过观察<code>table</code>列的顺序，可以确定查询中表的访问顺序。通常，第一个表（<code>id</code>最小的表）是驱动表，后续的表是被驱动表。</p>
<p>partitions：指示查询访问的表的分区信息（如果表被分区），不常用。</p>
<p><strong>type:</strong> 查询类型，指示查询优化器如何访问表中的数据，这个字段的值对查询性能有很大影响。</p>
<p>possible_keys：表示查询优化器可能使用的索引，用于提高查询速度</p>
<p>**key：**表示实际被使用的索引。</p>
<p>key_len：表示在查询中实际使用的索引字段数据的长度，以字节为单位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于单值索引</span><br><span class="line">key_len 表示索引字段的实际长度。例如，如果有一个 INT 类型的字段（通常占用 4 字节）作为索引，key_len 的值就是 4。如果是 VARCHAR(10) 字段，并且使用了完整的字段长度，key_len 可能是 30（假设字符集为 utf8，每个字符占用 3 字节，10 个字符即 30 字节）。</span><br><span class="line"></span><br><span class="line">对于复合索引</span><br><span class="line">key_len 表示使用的索引字段的总长度。例如，如果联合索引包含两个字段：INT 类型（4 字节）和 CHAR(10) 类型（假设占用 10 字节），那么 key_len 的值可能是 14。</span><br><span class="line"></span><br><span class="line">对于字符串类型字段</span><br><span class="line">key_len 会显示实际使用的字节长度。例如，如果有一个 VARCHAR(255) 字段，但实际查询中只使用了前 10 个字符，key_len 可能是 30（假设字符集为 utf8）。</span><br></pre></td></tr></table></figure>
<p>**ref：**指示与索引列进行比较的列或常量。</p>
<p><strong>rows</strong>：表示查询优化器预计需要扫描的行数。这个值越小，查询性能越好。</p>
<p>filtered：表示查询优化器预计经过过滤后保留的行的百分比，值越高，说明筛选条件越严格。</p>
<p><strong>Extra</strong>：额外的比较重要的信息，如 <code>Using where</code>（使用了 <code>WHERE</code> 条件过滤结果）、<code>Using index</code>（表示使用索引覆盖查询，无需回表查询）、<code>Using filesort</code>（需要额外的排序操作）、<code>Using temporary</code>（使用了临时表）、<code>Using join buffer</code>（表示使用连接缓冲区）等。</p>
<p><strong>拓展：</strong></p>
<p>select_type中的DERIVED：表示这个查询后的结果是一个派生表，即查询的结果被当作一个临时表使用，通常这个临时表是由子查询的结果构成的，也称为子查询或内联接子查询。派生表可以包含在主查询的 <code>FROM</code> 子句中，就像它是一个普通表一样，允许你对子查询的结果进行操作，比如进一步的筛选、排序或联接其他表。</p>
<p>当 <code>select_type</code> 为 <code>DERIVED</code> 时，这通常意味着查询优化器会递归执行子查询，并将结果放入一个临时表中，然后主查询可以使用这个临时表。这种派生表的使用可能会影响查询性能，特别是当子查询复杂或返回大量数据时。在优化查询时，考虑将派生表转换为连接（JOIN）或其他形式，可能会提高效率。</p>
<p>**type:**又称“访问类型”，表示表连接的类型，反映了MySQL决定如何查找表中的行。是较为重要的一个指标。结果从最好到最坏依次是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br><span class="line"></span><br><span class="line">system: 这是 const 连接类型的一个特例，表中只有一行数据或者是空表。</span><br><span class="line"></span><br><span class="line">const：常量表（例如，查询主键为常量的表）。通常发生在使用 PRIMARY KEY 或 UNIQUE 索引作为条件进行查找时，返回记录一定是1行记录的等值where条件。其他数据库也叫做唯一索引扫描，当查询的表仅有一行时,使用 system。</span><br><span class="line"></span><br><span class="line">eq_ref：唯一索引扫描,类似于 const，但用于多个值匹配的情况（例如，两表一对多的关系）。每个索引键最多只匹配一行，如 PRIMARY KEY 或 UNIQUE 索引的全部索引部分被匹配。</span><br><span class="line"></span><br><span class="line">ref：非唯一索引扫描表，返回数据不唯一的等值查找就可能出现。</span><br><span class="line">range：索引范围扫描，使用索引来查找一定范围内的值。</span><br><span class="line">Index：全索引扫描，查询优化器决定扫描整个索引。</span><br><span class="line">all：最差，指全表扫描数据文件，然后在server层进行过滤返回符合要求的记录。最坏的情况,从头到尾全表扫描。百万记录以下不用管，百万以上需要优化。</span><br><span class="line">----------------------</span><br><span class="line">fulltext：使用全文索引查找文本列中的关键词。</span><br><span class="line">ref_or_null：类似于 ref，但索引列的值可以是 NULL。</span><br><span class="line">index_merge：使用索引合并优化查询，即查询使用了两个以上的索引。</span><br><span class="line">unique_subquery：子查询返回唯一值。</span><br><span class="line">index_subquery：子查询返回多个值。</span><br></pre></td></tr></table></figure>
<p>type为all的地方，通常需要进行优化，一般需要达到 ref、eq_ref 级别，范围查找需要达到 range。</p>
<p>例子：</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555226439400.png" alt></p>
<p>id=2，最先执行，select_type为DERIVED表示这个查询的结果是一个派生表。也就是在 <code>FROM</code> 子句中的子查询，其结果被当作一个临时表来使用。在这个例子中，子查询 <code>select * from t1 where id = 1</code> 就是一个派生表，别名为 <code>d1</code>。它是where等值查询主键，type为const，常量表查找。</p>
<p>id=1，为外面一层查询，select_type为PRIMARY,是主键查询，table 为 <code>&lt;derived2&gt;</code>， <code>&lt;derived2&gt;</code>表示这是第二个查询（主查询中的派生表）的结果集，实际上对应的是 <code>d1</code> 这个派生表，type为system，派生表d1是一个只有一行的表,所以连接类型为 <code>system</code>。</p>
<p><strong>extra</strong>:额外的比较重要的信息，包含了查询优化器在执行查询时使用的额外步骤或者特性。有Using filesort、Using temporary 的一定需要优化，根据rows可以直观看出优化结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。利用覆盖索引，无需回表即可取得结果数据，这种结果是好的。</span><br><span class="line"></span><br><span class="line">using where：在查找使用索引的情况下，需要回表去查询所需的数据，需要在server层进行过滤。</span><br><span class="line"></span><br><span class="line">using filesort：</span><br><span class="line">不是利用磁盘的文件排序，而是通过内存排序。排序时无法使用到索引时，就会出现这个。</span><br><span class="line">常见于order by和group by语句中。没有办法利用现有索引进行排序，需要额外排序，建议：根据排序需要，创建相应合适的索引。</span><br><span class="line"></span><br><span class="line">using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看全局状态变量Created_tmp_tables和Created_tmp_disk_tables，它们分别记录了创建的内存临时表和磁盘临时表的数量，检查执行语句前后，这两个的变化情况，就能确定是内存还是磁盘。</span><br></pre></td></tr></table></figure>
<p><strong>覆盖索引</strong>（Covering Index）,一说为索引覆盖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">理解方式一：select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说**查询列要被所建的索引覆盖**。</span><br><span class="line"></span><br><span class="line">理解方式二：索引是高效找到行的一个方法，一般来说，数据库能通过索引找到一个列的数据，而不必读取整个行，因为索引叶子节点存储了它们索引的数据；</span><br><span class="line">当能通过读取索引就可以得到想要的数据，也就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引。</span><br></pre></td></tr></table></figure>
<p>注意：如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可<code>select *</code>,因为若将所有字段一起做索引会导致索引文件过大，查询性能下降。</p>
<p><strong>例子</strong></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555294548058.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">执行顺序1:</span><br><span class="line">id为4，select_type为union,说明第四个select是union里的第二个select,最先执行【select name,id,from t2】</span><br><span class="line"></span><br><span class="line">执行顺序2:</span><br><span class="line">id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived，即结果作为派生表。【select id,name from t1 where other_column = &#x27;&#x27;】</span><br><span class="line"></span><br><span class="line">执行顺序3:</span><br><span class="line">id为2，select列表中的子查询select_type为subquery,为整个查询中的第二个select。【select id from t3】</span><br><span class="line"></span><br><span class="line">执行顺序4:</span><br><span class="line">id为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被记为&lt;derived3&gt;，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name....】</span><br><span class="line"></span><br><span class="line">执行顺序5:</span><br><span class="line">id为null,代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</span><br><span class="line"></span><br><span class="line">&lt;union1,4&gt; 表示该行是 UNION 操作的结果集，它合并了查询中第一个和第四个 SELECT 语句的结果。UNION 操作会将两个或多个 SELECT 语句的结果集合并成一个结果集。</span><br></pre></td></tr></table></figure>
<h5 id="通过explain优化"><a class="markdownIt-Anchor" href="#通过explain优化"></a> <strong>通过explain优化</strong></h5>
<p>索引失效，口诀：</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555386995622.png" alt></p>
<p>简化：带头大哥不能少，中间兄弟不能断，索引列上少计算，范围之后全失效，百分like加右边，字符串里有引号。</p>
<p>解释：带头大哥不能少（第一字段，只要用了，不是非得它开头），中间兄弟不能断（断了索引只能用到前面的，后面用不上影响精确度，key_len和ref少了），索引列上少计算（动了容易索引失效，性能降低），范围之后全失效（索引用到范围字段为止，后面用不上索引），百分like加右边（若like '%字符%'必须用，则用覆盖索引解决），字符串里有引号（比如varchar类型,查询必须加单引号，如name=‘XXX’，否者索引失效）</p>
<p>单表分析：</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555304075969.png" alt></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555304162326.png" alt></p>
<p>range类型查询字段后面的索引无效，出现using filesort-&gt;删除索引，重建索引（将<code>&gt;</code>的字段去掉`）===中间兄弟没有断，索引字段可以跨where和order by使用。？？？</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555305079915.png" alt></p>
<p><code>category_id = 1</code> 可以利用索引快速定位，同时 <code>ORDER BY views DESC</code> 也可以利用索引的顺序，避免了文件排序（<code>Using filesort</code> 消失），提高了查询效率。</p>
<p>双表分析：</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555306250151.png" alt></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555306332660.png" alt></p>
<p>其实将class和book对调一下位置查询也是可以的，不用再删除</p>
<p>三表分析：</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555315348612.png" alt></p>
<p><code>LEFT JOIN</code> 中，驱动表通常是左边的表，尽管优化器可以调整连接顺序以提高性能，但在 <code>LEFT JOIN</code> 中，左表通常会被选为驱动表，因为必须保证左表的所有行都被保留。</p>
<p>建立索引：</p>
<ul>
<li><strong>连接条件列</strong> ：通常，应该在两个表的连接条件列上设置索引。对于左表，如果连接列上有过滤条件，索引会更有帮助。对于右表，索引可以加速匹配过程。</li>
<li><strong>查询过滤条件列</strong> ：如果查询中有针对某个表的过滤条件，那么在该表的相应列上设置索引可以提高过滤效率。</li>
<li><strong>覆盖查询索引</strong> ：理想情况下，索引应该覆盖查询中所有使用的列（即索引包含查询中涉及的所有列），以避免回表操作，提高查询性能。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后2行的type都是ref且总rows优化很好，效果不错。因此索引最好设置在需要经常查询的字段中。</span><br></pre></td></tr></table></figure>
<h5 id="查询优化where"><a class="markdownIt-Anchor" href="#查询优化where"></a> 查询优化（where）</h5>
<p>注意：</p>
<p><strong>1.尽量的扩展索引，不要新建索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</span><br></pre></td></tr></table></figure>
<p><strong>2.最左前缀匹配原则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配。</span><br><span class="line">比如a = 1 and b = 2 and c &gt; 3 and d = 4， 如果建立(a,b,c,d)顺序的索引，abc用到，d是用不到索引的，如果建立(a,b,d,c)的索引，则索引中的字段都可以用到，where后a,b,d的顺序可以任意调整。</span><br></pre></td></tr></table></figure>
<p><strong>3.=和in可以乱序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">比如建立(a,b,c)索引，where后a = 1 and b = 2 and c = 3 可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</span><br><span class="line">复合索引来说（a,b,c）其相当于3个索引（a），（a,b），（a,b,c）3个索引。</span><br><span class="line">in可以乱序. 但会导致回表查询——using where</span><br><span class="line"></span><br><span class="line">where和order by的字段会联和使用索引吗?</span><br><span class="line">答：会。</span><br><span class="line">如果表中建立2个单值索引c和v,where 用c,order by用v。实际上索引只用到了c,v并没有用到。由于查询优化器通常不会同时使用两个索引，order by排序操作无法用到索引v,需要回表查询，需要额外的处理，如文件排序Using filesort。</span><br><span class="line">而如果建立复合索引cv,则where条件有c,order by中有v排序，则形成了一个覆盖索引，使得查询和排序都可以直接通过索引完成，无需回表查询数据，避开Using filesort。</span><br><span class="line">若where用索引order by使用非索引字段，会导致filesort ,若where+in字段+order by非索引会导致索引失效。</span><br><span class="line"></span><br><span class="line">为什么where和order by使用单值索引，无法形成索引合并？</span><br><span class="line">答：因为查询优化器通常不会同时使用两个索引来同时满足 WHERE 和 ORDER BY 子句。因为索引合并主要用于在一个查询中使用多个索引进行条件过滤（如 OR 条件），而不是同时用于过滤和排序。如果查询需要排序，而排序列没有包含在用于过滤的索引中，MySQL 可能需要进行额外的排序操作（如文件排序 Using filesort），或者重新扫描数据以应用排序。</span><br><span class="line">即一条查询sql语句,查询优化器只会使用一个索引，而不会使用2个索引，除非复合索引合并的策略，比如or或and 或or中参和的范围查询。</span><br></pre></td></tr></table></figure>
<p><strong>4.索引列排序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。</span><br><span class="line">因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</span><br></pre></td></tr></table></figure>
<p><strong>5.尽量选择区分度高的列作为索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区分度的公式是count(distinct col)/count(*)，表示字段中数据不重复的比例，比例越大扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0</span><br></pre></td></tr></table></figure>
<p>一般需要join的字段都要求是0.1以上，即平均1条扫描10条记录。</p>
<p><strong>6.OR和AND</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OR条件的联合（union），AND条件的相交（intersection），两种情况的联合及相交，做联合操作时（通常是 or），通常耗费CPU、内存资源。</span><br><span class="line">如果是一个是单列索引，另一个非索引，那么会引发回表查询， explain 的 extra 显示 using where，此时先根据单列索引查到数据后，再回表进一步筛选非索引列。</span><br></pre></td></tr></table></figure>
<p><strong>7.使用短索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对字符串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和提高了索引的缓存效率，从而间接减少了磁盘 I/O 操作的次数。</span><br></pre></td></tr></table></figure>
<p>短索引创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_city ON table_name (city(3));</span><br><span class="line">这里city(3)表示索引只包含city字段的前3个字符，在应用短索引后，应该通过测试来评估其对查询性能的影响，确保它确实提高了效率。</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/qq_22238021/article/details/80922166">https://blog.csdn.net/qq_22238021/article/details/80922166</a></p>
<p><strong>实操</strong>：</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555384095779.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type: ref 表明使用了非唯一索引进行查找。</span><br><span class="line">使用了索引idx_test03_c1234，实际使用的字节数为62，</span><br><span class="line">ref: const,const 表示查询中使用了常量值来匹配索引字段。</span><br><span class="line">rows: 1 表示预计需要访问的行数。</span><br><span class="line">Using where 表示需要额外的条件过滤。</span><br><span class="line">没有 Using index 表示没有覆盖索引，需要回表查询。</span><br><span class="line"></span><br><span class="line">where匹配了c1c2前俩个字段用于过滤，order by利用c3的索引顺序进行排序，避免了using filesort文件排序，由于where跳过c3,所以c4需要回表查询获取。即最终是用到c1c2，c3用于排序但不统计。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555384696978.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分析第一条sql：where过滤用到了c1，order by 利用索引排序c2、c3直接获得，避免了using filesort文件排序。where中的c5需要回表查询。即最终用到了c1。</span><br><span class="line">分析第二条sql：where过滤用到了c1，order by 用的是c3、c2不符合索引顺序，所以需要回表查询，并且使用using filesort文件排序。where中的c5需要回表查询。即最终用到了c1。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555385202556.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分析第一条sql：where过滤用到了c1、c2，order by 用的是c3、c2不符合索引顺序，但由于c2已经被过滤使用，所以order by只需要排序c3,符合索引顺序，无需回表查询排序，避开了using filesort文件排序。where中的c5需要回表查询。即最终用到了c1、c2。</span><br><span class="line">分析第二条sql：</span><br><span class="line">where过滤用到了c1，order by 用的是c3、c2不符合索引顺序，所以需要回表查询，并且使用using filesort文件排序。where中的c5需要回表查询。即最终用到了c1。</span><br></pre></td></tr></table></figure>
<p>where a=3 and b like ‘kk%’ and c=4</p>
<p>like 后面是常量+%，虽是范围，但可落地，后面索引不失效</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555386841948.png" alt></p>
<p>一般性建议</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555386149521.png" alt></p>
<h5 id="查询优化order-by"><a class="markdownIt-Anchor" href="#查询优化order-by"></a> 查询优化（order by）</h5>
<p>若where未使用索引，order by使用了索引，有可能出现索引合并吗？</p>
<p>答：这种情况下不会出现索引合并，因为 <code>WHERE</code> 子句没有利用索引，说明它没有从索引中获取到数据行的过滤信息。而 <code>ORDER BY</code> 子句只是使用索引来对结果进行排序，并没有参与到行的过滤过程中。索引合并主要是为了优化行的过滤过程，提高 <code>WHERE</code> 子句的查询效率。在这种情况下，行的过滤是通过全表扫描等方式来进行的，没有出现多个不同索引用于过滤行的情况，所以不会发生索引合并。</p>
<p>where没有利用到索引，而order by利用到索引。这种情况也是有意义的，虽然需要回表查询数据，但索引排序可以减少排序的时间，避开了文件排序（filesort）。</p>
<p>order by多个字段，有索引会使用索引排序，但其中任何一个字段没有索引，就会利用filesort进行辅助排序，会有额外的IO开销和内存开销。filesort目前有两种排序算法，双路排序和单路排序。</p>
<p>双路排序与单路排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">双路排序查询数据时，只是将排序字段和记录ID加载到内存中，排好序后再根据id回表加载数据。 </span><br><span class="line">单路排序会一次性将数据查出到内存中，占用内存大，但效率高，因为排好序后就已经是可以返回的结果了。</span><br></pre></td></tr></table></figure>
<p>**<code>ORDER BY</code> 多字段排序时，索引失效的主因是：</p>
<ol>
<li><strong>字段顺序不匹配</strong>，<code>ORDER BY</code> 后的字段顺序与复合索引的字段顺序不一致。比如索引abc，而order by b,c,a，顺序不一致，导致索引失效。</li>
<li><strong>排序方向不匹配</strong>，<code>ORDER BY</code> 后的字段的排序方向与复合索引定义的排序方向不一致。比如索引a asc,b asc,而order by a desc,b asc。</li>
</ol>
<p>在建立复合索引时，可以建立一个一升序一降序的复合索引，通常不建议（会导致存储和维护更加复杂），而是使用默认排序（通常是升序）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_example ON table_name (column1 ASC, column2 DESC);</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555399507745.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">type为index表明使用了全索引扫描</span><br><span class="line">key为idx_A_ageBirth表明实际使用的索引是idx_A_ageBirth。</span><br><span class="line">extra中</span><br><span class="line">Using index 表示查询使用了索引，这意味着索引被用于快速检索数据行。</span><br><span class="line">Using filesort 表示 MySQL 需要进行额外的文件排序操作，而不是直接利用索引的顺序。</span><br><span class="line"></span><br><span class="line">key不是null,type不是all，extra中有”Using index;Using filesort“,说明不是所有失效，而是索引部分失效，原因是一升一降，与索引的默认字段排序不一致。</span><br><span class="line">在 MySQL 中，即使索引的默认顺序是升序（ASC），而查询使用的是降序（DESC）排序，索引仍然可以被使用。这是因为MySQL 的优化器会 可以通过反向扫描索引来满足降序排序的需求。</span><br></pre></td></tr></table></figure>
<p>提高Order By的速度</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555809463705.png" alt></p>
<p>小总结</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MySQL两种排序方式：文件排序、扫描有序索引排序</span><br><span class="line">排序和查询能使用相同的索引</span><br><span class="line"></span><br><span class="line">KEYa_b_c(a_b_c)</span><br><span class="line">order by能使用索引最左前缀</span><br><span class="line">-order by a</span><br><span class="line">-order by a,b</span><br><span class="line">-order by a,b,c</span><br><span class="line">-order by a desc,b desc,c desc</span><br><span class="line"></span><br><span class="line">如果where使用索引的最左前缀，order by能使用索引</span><br><span class="line">-where a=const order by b,c</span><br><span class="line">-where a=const and b=const order by c</span><br><span class="line">-where a=const and b&gt; const order by b,c</span><br><span class="line">where会用到a和b字段过滤，order by中由于b字段已经被过滤，只需要考虑c,符合索引字段顺序，order by利用索引排序而无需额外的文件排序操作。</span><br><span class="line">-where a in(...) order by b,c </span><br><span class="line">where子句索引只用到了a,order by 的字段和索引字段顺序一致，索引order by利用索引排序而无需额外的文件排序操作。</span><br><span class="line"></span><br><span class="line">不能使用索引进行排序</span><br><span class="line">order by a asc,b desc,c desc //字段排序不一致</span><br><span class="line">where g= const order by b,c //丢失a索引</span><br><span class="line">where a= const order by c //丢失b索引</span><br><span class="line">where a= const order by a,d //d不是索引的一部分</span><br></pre></td></tr></table></figure>
<h5 id="查询优化group-by"><a class="markdownIt-Anchor" href="#查询优化group-by"></a> 查询优化（group by）</h5>
<p>无法使用索引时，group by 使用两种策略来完成：临时表或者文件排序。</p>
<p>可以使用索引时，where和group在索引上的联系，类似于where和order by在索引上的联系，文件排序的预知相对类似（只要符合索引字段顺序），但在临时表上，相对难以预知，情况更复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAVING子句通常用于对分组后的结果再处理（在分组后的结果基础上过滤），where高于having，能写在where限定的条件就不要去having限定。</span><br><span class="line"></span><br><span class="line">当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置。</span><br></pre></td></tr></table></figure>
<p>临时表产生的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.索引覆盖和顺序</span><br><span class="line">索引是否覆盖了分组字段，以及是否覆盖了 SELECT 列表中所有需要的字段。如果都覆盖了，那么有较大可能不使用临时表。如果查询需要的字段不在索引中，即使分组字段有索引支持，也可能需要临时表来存储中间结果。</span><br><span class="line">2.聚合函数的影响 </span><br><span class="line">当查询中有聚合函数（如 COUNT(*)、SUM() 等）时，即使索引覆盖了分组字段，也可能需要使用临时表来辅助计算聚合结果。因为需要先对分组后的数据进行聚合计算，再返回最终结果。</span><br><span class="line">3.多表连接和子查询</span><br><span class="line">如果查询涉及到多个表的连接、子查询等复杂操作，情况就更加复杂。优化器需要综合考虑多个因素来决定是否使用临时表或文件排序。</span><br></pre></td></tr></table></figure>
<p>group by实质是先排序后进行分组（在MySQL的早期版本是这样，但从MySQL 8.0开始，GROUP BY 语句不会在分组前先进行排序，默认也不再包含隐式排序。），遵照索引的最佳左前缀。这里的“排序”指 <code>GROUP BY</code> 操作本身的内部排序。</p>
<h4 id="查询截取分析"><a class="markdownIt-Anchor" href="#查询截取分析"></a> 查询截取分析</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.观察，至少跑1天，看看生产的慢SQL情况。</span><br><span class="line">2.开启慢查询日志，设置阙值，比如超过5秒钟就是慢SQL，并将它抓取出来。</span><br><span class="line">3.explain + 慢SQL分析</span><br><span class="line">4.show profile 检查执行细节和生命周期</span><br><span class="line">5.运维经理 或 DBA,进行SQL数据库服务器的参数调优</span><br></pre></td></tr></table></figure>
<p>总结</p>
<p>1.慢查询的开启并捕获</p>
<p>2.explain + 慢SQL分析</p>
<p>3.show profile查询SQL在MySQL服务器里面的执行细节和生命周期情况</p>
<p>4.SQL数据库服务器的参数调优。</p>
<p>Show profile :</p>
<p>是mysql 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于sql 调优的测量。<strong>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</strong></p>
<h5 id="慢查询日志"><a class="markdownIt-Anchor" href="#慢查询日志"></a> 慢查询日志</h5>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555810980572.png" alt></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555811815331.png" alt></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555811881764.png" alt></p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555817190855.png" alt></p>
<p>用select sleep(4)命令，模拟超过超过3s的慢sql</p>
<p>mysqld配置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line"></span><br><span class="line">slow_query_log_file=/var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line">long_query_time=3</span><br><span class="line"></span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure>
<p>日志分析工具mysqldumpslow</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysqldumpslow --help</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555818578413.png" alt></p>
<p>mysqldumpslow的帮助信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s:是表示按照何种凡=方式排序</span><br><span class="line">c:访问次数</span><br><span class="line">I:锁定时间</span><br><span class="line">r:返回记录</span><br><span class="line">t:查询时间</span><br><span class="line">al:平均锁定时间</span><br><span class="line">ar:平均返回记录数</span><br><span class="line">at:平均查询时间</span><br><span class="line">t:即为返回前面多少条的数据</span><br><span class="line">g:后边搭配一个正则匹配模式，大小写不敏感的</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555818473017.png" alt></p>
<h5 id="批量数据脚本"><a class="markdownIt-Anchor" href="#批量数据脚本"></a> 批量数据脚本</h5>
<p>插入数据1000万条，为防止压坏，每次插入50w条数据</p>
<p>建表插入数据后会报错，解决办法</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555819321180.png" alt></p>
<p>1、随机产生字符串</p>
<p>substring(字符串，开始位置，长度)截取字符串</p>
<p>concat(str,str)字符串连接，如果有任何一个参数为null，则返回值为null</p>
<p>concat(str1, seperator,str2,seperator,…)返回结果为连接参数产生的字符串并且有分隔符，如果有任何一个参数为null，则返回值为null</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555820247537.png" alt>2、随机产生部门编号</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555820517707.png" alt></p>
<p>3、创建存储过程</p>
<p>emp表中插入数据insert_emp(开始编号，插入条数)</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555821828985.png" alt></p>
<p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delimiter;</span><br></pre></td></tr></table></figure>
<p>drop procedure insert_em;</p>
<p>dept表中插入数据</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555822396356.png" alt>4、调用存储过程</p>
<p>​	插入10个部门</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555822698414.png" alt></p>
<p><strong>Show Profile</strong></p>
<p>1、查看是否支持</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Show  variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure>
<p>2、开启功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;set profiling=on;</span><br></pre></td></tr></table></figure>
<p>3、运行sql</p>
<p>4、查看结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;show profile</span><br></pre></td></tr></table></figure>
<p>5、诊断sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;show profile cpu,block io for query </span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555847075431.png" alt></p>
<p><strong>全局查询日志</strong></p>
<p>只能在测试环境用，不可用于生产</p>
<p>配置启用</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555848649926.png" alt></p>
<p>编码启用</p>
<p><img src="/2019/04/22/mysql%E4%BC%98%E5%8C%96/1555848739640.png" alt></p>
<h4 id="子查询和join如何选择"><a class="markdownIt-Anchor" href="#子查询和join如何选择"></a> 子查询和JOIN如何选择</h4>
<p>每join一个表就嵌套一层循环，但总体上是只查询了一次。而子查询，每多一个子查询，则会多一次查询。</p>
<p>MySQL中的子查询和JOIN查询在性能上有所不同，具体取决于数据量和查询的类型。以下是关于这两种查询方式的详细讨论：</p>
<p>JOIN查询：</p>
<ul>
<li>优点：JOIN查询可以将多个表的数据通过关联条件联合起来，一次性处理多个表的记录，提高了查询效率。</li>
<li>缺点：如果在JOIN查询中使用的连接条件不当，可能会导致查询结果出错。另外，由于需要连接多个表，因此对于连接的表数量的上限有所限制，超过这个数量后，查询性能可能会降低。</li>
</ul>
<p>子查询：</p>
<ul>
<li>优点：子查询能够在一个查询中嵌套另一个查询，实现更为复杂的查询逻辑。</li>
<li>缺点：子查询会导致查询过程变得更复杂，因为它们通常在主查询执行之前就已经完成计算。如果子查询的结果集非常大，其执行速度可能相对较慢。</li>
</ul>
<p>在某些情况下，如数据量较小（例如1000条数据），使用JOIN查询的时间会更短，而在数据量较大的情况下（例如1000000条数据），使用IN子查询的性能会更好。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN (SELECT department_id</span><br><span class="line">                        FROM departments</span><br><span class="line">                        WHERE department_name = &#x27;Sales&#x27;);</span><br></pre></td></tr></table></figure>
<p>然而，如果子查询的结果集过大，可能导致SQL语句过长，甚至无法执行。此外，如果存在分页需求，IN子查询也无法满足。</p>
<p>综上所述，JOIN查询在大多数情况下是更好的选择，尤其是在处理大量数据时。但是，如果子查询的结果集很小且不需要分页，那么子查询也是一个有效的解决方案。在实际应用中，应根据具体的业务需求和数据量来选择最合适的方法。</p>
<p>可参考：</p>
<p><a href="https://blog.51cto.com/u_16099232/6712681">https://blog.51cto.com/u_16099232/6712681</a></p>
<p><a href="https://www.shence123.com/s/23262.html">https://www.shence123.com/s/23262.html</a></p>
<p><strong>子查询可以分页吗？</strong></p>
<p>子查询（Subquery）本身可以用于实现分页功能，但是它们并不总是分页查询的最佳选择。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> some_column LIMIT <span class="number">1000</span></span><br><span class="line">) <span class="keyword">AS</span> subquery</span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>
<p>外层查询的 <code>LIMIT 10</code> 表示要获取10条记录，<code>OFFSET 90</code> 表示从内部查询结果的第91条记录开始获取。</p>
<p>分析：</p>
<p>子查询可能遇到以下问题：</p>
<ol>
<li><strong>性能问题</strong>：如果内部查询返回了大量的数据，这可能会导致性能问题，因为数据库需要先处理内部查询的所有数据，然后再由外部查询进行分页。</li>
<li><strong>资源消耗</strong>：子查询可能会消耗更多的服务器资源，尤其是当处理大量数据时。</li>
<li><strong>复杂性</strong>：在某些情况下，子查询可能会使 SQL 语句变得更加复杂，难以理解和维护。</li>
<li><strong>限制</strong>：在某些数据库系统中，子查询的使用可能受到限制，或者在性能上不如直接使用 <code>LIMIT</code> 和 <code>OFFSET</code>。</li>
</ol>
<p>通常建议：</p>
<ul>
<li><strong>直接使用 <code>LIMIT</code> 和 <code>OFFSET</code></strong>：这是最简单直接的方法，适用于大多数情况。</li>
<li><strong>使用行号</strong>：在一些数据库系统中，可以使用行号（如 MySQL 的 <code>ROW_NUMBER()</code> 函数）来实现分页，这通常比使用 <code>OFFSET</code> 更高效。</li>
<li><strong>索引</strong>：确保用于排序和分页的列上有适当的索引，以提高查询性能。</li>
</ul>
<p>如何将Mysql2个性质相同的表的数据做排序分页</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1. 使用 UNION ALL 合并两个表的数据</span><br><span class="line">UNION ALL 用于合并两个或多个 SELECT 语句的结果集。UNION ALL 会保留重复记录，而 UNION 会自动去除重复记录。如果不需要去重，使用 UNION ALL 可以减少内存消耗和处理时间。</span><br><span class="line">2. 使用 ORDER BY 进行排序</span><br><span class="line">在合并后的结果集上使用 ORDER BY 进行排序。</span><br><span class="line">3. 使用 LIMIT 和 OFFSET 进行分页</span><br><span class="line">在排序后的结果集上使用 LIMIT 和 OFFSET 进行分页。</span><br><span class="line"></span><br><span class="line">SELECT id, name, value</span><br><span class="line">FROM (</span><br><span class="line">    SELECT id, name, value FROM table1</span><br><span class="line">    UNION ALL</span><br><span class="line">    SELECT id, name, value FROM table2</span><br><span class="line">) AS combined</span><br><span class="line">ORDER BY value DESC</span><br><span class="line">LIMIT 2 OFFSET 2;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.字段一致性 ：确保两个表的字段数量和类型一致，否则 UNION ALL 可能会报错。</span><br><span class="line">2.性能 ：如果两个表的数据量较大，UNION ALL 和 ORDER BY 可能会影响性能。可以考虑为排序字段添加索引以提高效率。</span><br><span class="line">3.去重 ：如果需要去除重复记录，可以使用 UNION 代替 UNION ALL，但 UNION 会自动对结果进行排序，这可能会增加额外的性能开销。</span><br><span class="line"></span><br><span class="line">如果数据量过大，内存不足怎么办？</span><br><span class="line">1.两个表数据合并到一个表中。</span><br><span class="line">2.调整 MySQL 配置：增加可用内存（如 tmp_table_size 和 max_heap_table_size），以支持更大的内存表操作。为合并操作中的排序字段添加索引，可以提高排序效率，减少内存消耗。</span><br><span class="line">3.分批处理数据：使用 LIMIT 和 OFFSET 来分批获取数据</span><br><span class="line">SELECT *</span><br><span class="line">FROM (</span><br><span class="line">    SELECT * FROM table1</span><br><span class="line">    UNION ALL</span><br><span class="line">    SELECT * FROM table2</span><br><span class="line">) AS combined</span><br><span class="line">ORDER BY id</span><br><span class="line">LIMIT 1000 OFFSET 0;</span><br><span class="line">4.使用临时表</span><br><span class="line">会话结束 ：当创建临时表的客户端会话结束时，临时表会自动删除。这是为了释放资源并避免临时表占用过多存储空间。</span><br><span class="line">显式删除 ：可以使用 DROP TEMPORARY TABLE 语句显式删除临时表。</span><br><span class="line"></span><br><span class="line">CREATE TEMPORARY TABLE temp_table AS</span><br><span class="line">SELECT * FROM table1</span><br><span class="line">LIMIT 1000 OFFSET 0;</span><br><span class="line"></span><br><span class="line">INSERT INTO temp_table</span><br><span class="line">SELECT * FROM table2</span><br><span class="line">LIMIT 1000 OFFSET 0;</span><br><span class="line"></span><br><span class="line">SELECT * FROM temp_table</span><br><span class="line">ORDER BY id;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/22/mysql%E4%BC%98%E5%8C%96/" data-id="cmbkfknf4001xl0lidupn6if3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/23/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          MySQL锁机制
        
      </div>
    </a>
  
  
    <a href="/2019/03/20/linux-%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux命令补充</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ComputerNetwork/" rel="tag">ComputerNetwork</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Front-end/" rel="tag">Front-end</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OperatingSystem/" rel="tag">OperatingSystem</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP-framework/" rel="tag">PHP-framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SoftwareDevelopment/" rel="tag">SoftwareDevelopment</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/" rel="tag">Tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm-data-structure/" rel="tag">algorithm-data_structure</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ComputerNetwork/" style="font-size: 16.67px;">ComputerNetwork</a> <a href="/tags/Docker/" style="font-size: 12.22px;">Docker</a> <a href="/tags/Front-end/" style="font-size: 11.11px;">Front-end</a> <a href="/tags/Git/" style="font-size: 13.33px;">Git</a> <a href="/tags/Golang/" style="font-size: 14.44px;">Golang</a> <a href="/tags/Hexo/" style="font-size: 12.22px;">Hexo</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 11.11px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 20px;">MySQL</a> <a href="/tags/OperatingSystem/" style="font-size: 17.78px;">OperatingSystem</a> <a href="/tags/PHP/" style="font-size: 17.78px;">PHP</a> <a href="/tags/PHP-framework/" style="font-size: 15.56px;">PHP-framework</a> <a href="/tags/Redis/" style="font-size: 16.67px;">Redis</a> <a href="/tags/SoftwareDevelopment/" style="font-size: 18.89px;">SoftwareDevelopment</a> <a href="/tags/Tool/" style="font-size: 13.33px;">Tool</a> <a href="/tags/algorithm-data-structure/" style="font-size: 15.56px;">algorithm-data_structure</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/05/25/JWT%E5%AE%9E%E6%88%98/">JWT实战</a>
          </li>
        
          <li>
            <a href="/2025/05/16/CSRF%E6%A6%82%E8%BF%B0%E5%92%8CBeego%E9%85%8D%E7%BD%AE/">CSRF概述和Beego配置</a>
          </li>
        
          <li>
            <a href="/2025/05/05/SQL%E6%B3%A8%E5%85%A5%E4%B8%8EXSS/">SQL注入与XSS</a>
          </li>
        
          <li>
            <a href="/2025/04/27/%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/">服务程序后台运行</a>
          </li>
        
          <li>
            <a href="/2025/04/17/Linux%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux通用命令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 abellmz<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>